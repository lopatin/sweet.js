"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tokenizer = require("shift-parser/dist/tokenizer");

var _tokenizer2 = _interopRequireDefault(_tokenizer);

var _immutable = require("immutable");

var _syntax = require("./syntax");

var _syntax2 = _interopRequireDefault(_syntax);

var _ramda = require("ramda");

var R = _interopRequireWildcard(_ramda);

var _ramdaFantasy = require("ramda-fantasy");

var _errors = require("./errors");

var _terms = require("./terms");

var _terms2 = _interopRequireDefault(_terms);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Just = _ramdaFantasy.Maybe.Just;
const Nothing = _ramdaFantasy.Maybe.Nothing;


const LSYNTAX = { name: 'left-syntax' };
const RSYNTAX = { name: 'right-syntax' };
const AT = { klass: _tokenizer.TokenClass.Punctuator, name: "@" };

// TODO: also, need to handle contextual yield
const literalKeywords = ['this', 'null', 'true', 'false'];

// Token -> Boolean
const isLeftBracket = R.whereEq({ type: _tokenizer.TokenType.LBRACK });
const isLeftBrace = R.whereEq({ type: _tokenizer.TokenType.LBRACE });
const isLeftParen = R.whereEq({ type: _tokenizer.TokenType.LPAREN });
const isRightBracket = R.whereEq({ type: _tokenizer.TokenType.RBRACK });
const isRightBrace = R.whereEq({ type: _tokenizer.TokenType.RBRACE });
const isRightParen = R.whereEq({ type: _tokenizer.TokenType.RPAREN });

const isEOS = R.whereEq({ type: _tokenizer.TokenType.EOS });

// const isHash = R.whereEq({ type: TokenType.IDENTIFIER, value: '#'});
const isLeftSyntax = R.whereEq({ type: LSYNTAX });
const isRightSyntax = R.whereEq({ type: RSYNTAX });

const isLeftDelimiter = R.anyPass([isLeftBracket, isLeftBrace, isLeftParen, isLeftSyntax]);

const isRightDelimiter = R.anyPass([isRightBracket, isRightBrace, isRightParen, isRightSyntax]);

const isMatchingDelimiters = R.cond([[isLeftBracket, (_, b) => isRightBracket(b)], [isLeftBrace, (_, b) => isRightBrace(b)], [isLeftParen, (_, b) => isRightParen(b)], [isLeftSyntax, (_, b) => isRightSyntax(b)], [R.T, R.F]]);

const assignOps = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ","];

const binaryOps = ["+", "-", "*", "/", "%", "<<", ">>", ">>>", "&", "|", "^", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!==", "instanceof"];

const unaryOps = ["++", "--", "~", "!", "delete", "void", "typeof", "yield", "throw", "new"];

// List -> Boolean
const isEmpty = R.whereEq({ size: 0 });

// Syntax -> Boolean
const isPunctuator = s => s.match("punctuator");
const isKeyword = s => s.match("keyword");
const isParens = s => s.match("parens");
const isBraces = s => s.match("braces");
const isIdentifier = s => s.match("identifier");

// Any -> Syntax -> Boolean
const isVal = R.curry((v, s) => s.val() === v);

// Syntax -> Boolean
const isDot = R.allPass([isPunctuator, isVal('.')]);
const isColon = R.allPass([isPunctuator, isVal(':')]);
const isFunctionKeyword = R.allPass([isKeyword, isVal('function')]);
const isOperator = s => (s.match("punctuator") || s.match("keyword")) && R.any(R.equals(s.val()), assignOps.concat(binaryOps).concat(unaryOps));
const isNonLiteralKeyword = R.allPass([isKeyword, s => R.none(R.equals(s.val()), literalKeywords)]);
const isKeywordExprPrefix = R.allPass([isKeyword, s => R.any(R.equals(s.val()), ['instanceof', 'typeof', 'delete', 'void', 'yield', 'throw', 'new', 'case'])]);
// List a -> a?
let last = p => p.last();
// List a -> Maybe a
let safeLast = R.pipe(R.cond([[isEmpty, R.always(Nothing())], [R.T, R.compose(_ramdaFantasy.Maybe.of, last)]]));

// TODO: better name
// List -> Boolean -> Maybe List
let stuffTrue = R.curry((p, b) => b ? Just(p) : Nothing());
let stuffFalse = R.curry((p, b) => !b ? Just(p) : Nothing());

// List a -> Boolean
let isTopColon = R.pipe(safeLast, R.map(isColon), _ramdaFantasy.Maybe.maybe(false, R.identity));
// List a -> Boolean
let isTopPunctuator = R.pipe(safeLast, R.map(isPunctuator), _ramdaFantasy.Maybe.maybe(false, R.identity));

// Number -> List -> Boolean
let isExprReturn = R.curry((l, p) => {
  let retKwd = safeLast(p);
  let maybeDot = pop(p).chain(safeLast);

  if (maybeDot.map(isDot).getOrElse(false)) {
    return true;
  }
  return retKwd.map(s => {
    return s.match("keyword") && s.val() === 'return' && s.lineNumber() === l;
  }).getOrElse(false);
});

const isTopOperator = R.pipe(safeLast, R.map(isOperator), _ramdaFantasy.Maybe.maybe(false, R.identity));

const isTopKeywordExprPrefix = R.pipe(safeLast, R.map(isKeywordExprPrefix), _ramdaFantasy.Maybe.maybe(false, R.identity));

// Number -> Boolean -> List -> Boolean
let isExprPrefix = R.curry((l, b) => R.cond([
// ... ({x: 42} /r/i)
[isEmpty, R.always(b)],
// ... ({x: {x: 42} /r/i })
[isTopColon, R.always(b)],
// ... throw {x: 42} /r/i
[isTopKeywordExprPrefix, R.T],
// ... 42 + {x: 42} /r/i
[isTopOperator, R.T],
// ... for ( ; {x: 42}/r/i)
[isTopPunctuator, R.always(b)],
// ... return {x: 42} /r /i
// ... return\n{x: 42} /r /i
[isExprReturn(l), R.T], [R.T, R.F]]));

// List a -> Maybe List a
let curly = p => safeLast(p).map(isBraces).chain(stuffTrue(p));
let paren = p => safeLast(p).map(isParens).chain(stuffTrue(p));
let func = p => safeLast(p).map(isFunctionKeyword).chain(stuffTrue(p));
let ident = p => safeLast(p).map(isIdentifier).chain(stuffTrue(p));
let nonLiteralKeyword = p => safeLast(p).map(isNonLiteralKeyword).chain(stuffTrue(p));

let opt = R.curry((a, b, p) => {
  let result = R.pipeK(a, b)(_ramdaFantasy.Maybe.of(p));
  return _ramdaFantasy.Maybe.isJust(result) ? result : _ramdaFantasy.Maybe.of(p);
});

let notDot = R.ifElse(R.whereEq({ size: 0 }), Just, p => safeLast(p).map(s => !(s.match("punctuator") && s.val() === '.')).chain(stuffTrue(p)));

// List a -> Maybe List a
let pop = R.compose(Just, p => p.pop());

// Maybe List a -> Maybe List a
const functionPrefix = R.pipeK(curly, pop, paren, pop, opt(ident, pop), func);

// Boolean -> List a -> Boolean
const isRegexPrefix = b => R.anyPass([
// ε
isEmpty,
// P . t   where t ∈ Punctuator
isTopPunctuator,
// P . t . t'  where t \not = "." and t' ∈ (Keyword \setminus  LiteralKeyword)
R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust),
// P . t . t' . (T)  where t \not = "." and t' ∈ (Keyword \setminus LiteralKeyword)
R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(paren, pop, nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust),
// P . function^l . x? . () . {}     where isExprPrefix(P, b, l) = false
R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, R.chain(p => {
  return safeLast(p).map(s => s.lineNumber()).chain(fnLine => {
    return pop(p).map(isExprPrefix(fnLine, b));
  }).chain(stuffFalse(p));
}), _ramdaFantasy.Maybe.isJust),
// P . {T}^l  where isExprPrefix(P, b, l) = false
p => {
  let alreadyCheckedFunction = R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, _ramdaFantasy.Maybe.isJust)(p);
  if (alreadyCheckedFunction) {
    return false;
  }
  return R.pipe(_ramdaFantasy.Maybe.of, R.chain(curly), R.chain(p => {
    return safeLast(p).map(s => s.lineNumber()).chain(curlyLine => {
      return pop(p).map(isExprPrefix(curlyLine, b));
    }).chain(stuffFalse(p));
  }), _ramdaFantasy.Maybe.isJust)(p);
}]);

function lastEl(l) {
  return l[l.length - 1];
}

class Reader extends _tokenizer2.default {
  constructor(strings, context, replacements) {
    super(Array.isArray(strings) ? strings.join('') : strings);
    this.delimStack = new Map();
    this.insideSyntaxTemplate = [false];
    this.context = context;

    // setup splicing replacement array
    if (Array.isArray(strings)) {
      let totalIndex = 0;
      this.replacementIndex = R.reduce((acc, strRep) => {
        acc.push({
          index: totalIndex + strRep[0].length,
          replacement: strRep[1]
        });
        totalIndex += strRep[0].length;
        return acc;
      }, [], R.zip(strings, replacements));
    }
  }

  read() {
    let stack = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let singleDelimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    let prefix = (0, _immutable.List)();
    while (true) {
      let tok = this.advance(prefix, b);

      // splicing allows syntax and terms
      if (tok.scopesets || tok instanceof _terms2.default) {
        stack.push(tok);
        continue;
      }
      if (Array.isArray(tok)) {
        Array.prototype.push.apply(stack, tok);
        continue;
      }
      if (_immutable.List.isList(tok)) {
        Array.prototype.push.apply(stack, tok.toArray());
        continue;
      }

      if (isEOS(tok)) {
        if (stack[0] && isLeftDelimiter(stack[0].token)) {
          throw this.createUnexpected(tok);
        }
        break;
      }

      if (isLeftDelimiter(tok)) {
        if (isLeftSyntax(tok)) {
          this.insideSyntaxTemplate.push(true);
        }
        let line = tok.slice.startLocation.line;
        let innerB = isLeftBrace(tok) ? isExprPrefix(line, b)(prefix) : true;
        let inner = this.read([new _syntax2.default(tok, this.context)], innerB, false);
        let stx = new _syntax2.default(inner, this.context);
        prefix = prefix.concat(stx);
        stack.push(stx);
        if (singleDelimiter) {
          break;
        }
      } else if (isRightDelimiter(tok)) {
        if (stack[0] && !isMatchingDelimiters(stack[0].token, tok)) {
          throw this.createUnexpected(tok);
        }
        let stx = new _syntax2.default(tok, this.context);
        stack.push(stx);
        if (lastEl(this.insideSyntaxTemplate) && isRightSyntax(tok)) {
          this.insideSyntaxTemplate.pop();
        }
        break;
      } else {
        let stx = new _syntax2.default(tok, this.context);
        prefix = prefix.concat(stx);
        stack.push(stx);
      }
    }
    return (0, _immutable.List)(stack);
  }

  advance(prefix, b) {
    this.lastIndex = this.index;
    this.lastLine = this.line;
    this.lastLineStart = this.lineStart;

    this.skipComment();

    this.startIndex = this.index;
    this.startLine = this.line;
    this.startLineStart = this.lineStart;

    if (this.replacementIndex && this.replacementIndex[0] && this.index >= this.replacementIndex[0].index) {
      let rep = this.replacementIndex[0].replacement;
      this.replacementIndex.shift();
      return rep;
    }

    let charCode = this.source.charCodeAt(this.index);

    if (charCode === 0x60) {
      // `
      let element,
          items = [];
      let startLocation = this.getLocation();
      let start = this.index;
      this.index++;
      if (lastEl(this.insideSyntaxTemplate)) {

        let slice = this.getSlice(start, startLocation);
        return {
          type: RSYNTAX,
          value: '`',
          slice: slice
        };
      }
      do {
        element = this.scanTemplateElement();
        items.push(element);
        if (element.interp) {
          // only read the single delimiter
          element = this.read([], false, true);
          (0, _errors.assert)(element.size === 1, "should only have read a single delimiter inside a template");
          items.push(element.get(0));
        }
      } while (!element.tail);
      return {
        type: _tokenizer.TokenType.TEMPLATE,
        items: (0, _immutable.List)(items),
        slice: this.getSlice(start, startLocation)
      };
    } else if (charCode === 35) {
      // #
      let startLocation = this.getLocation();
      let start = this.index;
      let slice = this.getSlice(start, startLocation);
      this.index++;
      // TODO: handle ` inside of syntax template interpolations
      if (this.source.charCodeAt(this.index) === 0x60) {
        // `
        this.index++;
        return {
          type: LSYNTAX,
          value: '#`',
          slice: slice
        };
      }
      return {
        type: _tokenizer.TokenType.IDENTIFIER,
        value: '#',
        slice: slice
      };
    } else if (charCode === 64) {
      // @
      let startLocation = this.getLocation();
      let start = this.index;
      let slice = this.getSlice(start, startLocation);
      this.index++;
      return {
        type: AT,
        value: '@',
        slice: slice
      };
    }

    let lookahead = super.advance();
    if (lookahead.type === _tokenizer.TokenType.DIV && isRegexPrefix(b)(prefix)) {
      return super.scanRegExp("/");
    }
    return lookahead;
  }

  // need to override how templates are lexed because of delimiters
  scanTemplateElement() {
    let startLocation = this.getLocation();
    let start = this.index;
    while (this.index < this.source.length) {
      let ch = this.source.charCodeAt(this.index);
      switch (ch) {
        case 0x60:
          {
            // `
            // don't include the traling "`"
            let slice = this.getSlice(start, startLocation);
            this.index++;
            return {
              type: _tokenizer.TokenType.TEMPLATE,
              tail: true,
              interp: false,
              slice: slice
            };
          }
        case 0x24:
          // $
          if (this.source.charCodeAt(this.index + 1) === 0x7B) {
            // {
            // don't include the trailing "$"
            let slice = this.getSlice(start, startLocation);
            this.index += 1;
            return {
              type: _tokenizer.TokenType.TEMPLATE,
              tail: false,
              interp: true,
              slice: slice
            };
          }
          this.index++;
          break;
        case 0x5C:
          // \\
          {
            let octal = this.scanStringEscape("", null)[1];
            if (octal != null) {
              throw this.createILLEGAL();
            }
            break;
          }
        default:
          this.index++;
      }
    }

    throw this.createILLEGAL();
  }
}
exports.default = Reader;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGlmdC1yZWFkZXIuanMiXSwibmFtZXMiOlsiUiIsIkp1c3QiLCJOb3RoaW5nIiwiTFNZTlRBWCIsIm5hbWUiLCJSU1lOVEFYIiwiQVQiLCJrbGFzcyIsIlB1bmN0dWF0b3IiLCJsaXRlcmFsS2V5d29yZHMiLCJpc0xlZnRCcmFja2V0Iiwid2hlcmVFcSIsInR5cGUiLCJMQlJBQ0siLCJpc0xlZnRCcmFjZSIsIkxCUkFDRSIsImlzTGVmdFBhcmVuIiwiTFBBUkVOIiwiaXNSaWdodEJyYWNrZXQiLCJSQlJBQ0siLCJpc1JpZ2h0QnJhY2UiLCJSQlJBQ0UiLCJpc1JpZ2h0UGFyZW4iLCJSUEFSRU4iLCJpc0VPUyIsIkVPUyIsImlzTGVmdFN5bnRheCIsImlzUmlnaHRTeW50YXgiLCJpc0xlZnREZWxpbWl0ZXIiLCJhbnlQYXNzIiwiaXNSaWdodERlbGltaXRlciIsImlzTWF0Y2hpbmdEZWxpbWl0ZXJzIiwiY29uZCIsIl8iLCJiIiwiVCIsIkYiLCJhc3NpZ25PcHMiLCJiaW5hcnlPcHMiLCJ1bmFyeU9wcyIsImlzRW1wdHkiLCJzaXplIiwiaXNQdW5jdHVhdG9yIiwicyIsIm1hdGNoIiwiaXNLZXl3b3JkIiwiaXNQYXJlbnMiLCJpc0JyYWNlcyIsImlzSWRlbnRpZmllciIsImlzVmFsIiwiY3VycnkiLCJ2IiwidmFsIiwiaXNEb3QiLCJhbGxQYXNzIiwiaXNDb2xvbiIsImlzRnVuY3Rpb25LZXl3b3JkIiwiaXNPcGVyYXRvciIsImFueSIsImVxdWFscyIsImNvbmNhdCIsImlzTm9uTGl0ZXJhbEtleXdvcmQiLCJub25lIiwiaXNLZXl3b3JkRXhwclByZWZpeCIsImxhc3QiLCJwIiwic2FmZUxhc3QiLCJwaXBlIiwiYWx3YXlzIiwiY29tcG9zZSIsIm9mIiwic3R1ZmZUcnVlIiwic3R1ZmZGYWxzZSIsImlzVG9wQ29sb24iLCJtYXAiLCJtYXliZSIsImlkZW50aXR5IiwiaXNUb3BQdW5jdHVhdG9yIiwiaXNFeHByUmV0dXJuIiwibCIsInJldEt3ZCIsIm1heWJlRG90IiwicG9wIiwiY2hhaW4iLCJnZXRPckVsc2UiLCJsaW5lTnVtYmVyIiwiaXNUb3BPcGVyYXRvciIsImlzVG9wS2V5d29yZEV4cHJQcmVmaXgiLCJpc0V4cHJQcmVmaXgiLCJjdXJseSIsInBhcmVuIiwiZnVuYyIsImlkZW50Iiwibm9uTGl0ZXJhbEtleXdvcmQiLCJvcHQiLCJhIiwicmVzdWx0IiwicGlwZUsiLCJpc0p1c3QiLCJub3REb3QiLCJpZkVsc2UiLCJmdW5jdGlvblByZWZpeCIsImlzUmVnZXhQcmVmaXgiLCJmbkxpbmUiLCJhbHJlYWR5Q2hlY2tlZEZ1bmN0aW9uIiwiY3VybHlMaW5lIiwibGFzdEVsIiwibGVuZ3RoIiwiUmVhZGVyIiwiY29uc3RydWN0b3IiLCJzdHJpbmdzIiwiY29udGV4dCIsInJlcGxhY2VtZW50cyIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJkZWxpbVN0YWNrIiwiTWFwIiwiaW5zaWRlU3ludGF4VGVtcGxhdGUiLCJ0b3RhbEluZGV4IiwicmVwbGFjZW1lbnRJbmRleCIsInJlZHVjZSIsImFjYyIsInN0clJlcCIsInB1c2giLCJpbmRleCIsInJlcGxhY2VtZW50IiwiemlwIiwicmVhZCIsInN0YWNrIiwic2luZ2xlRGVsaW1pdGVyIiwicHJlZml4IiwidG9rIiwiYWR2YW5jZSIsInNjb3Blc2V0cyIsInByb3RvdHlwZSIsImFwcGx5IiwiaXNMaXN0IiwidG9BcnJheSIsInRva2VuIiwiY3JlYXRlVW5leHBlY3RlZCIsImxpbmUiLCJzbGljZSIsInN0YXJ0TG9jYXRpb24iLCJpbm5lckIiLCJpbm5lciIsInN0eCIsImxhc3RJbmRleCIsImxhc3RMaW5lIiwibGFzdExpbmVTdGFydCIsImxpbmVTdGFydCIsInNraXBDb21tZW50Iiwic3RhcnRJbmRleCIsInN0YXJ0TGluZSIsInN0YXJ0TGluZVN0YXJ0IiwicmVwIiwic2hpZnQiLCJjaGFyQ29kZSIsInNvdXJjZSIsImNoYXJDb2RlQXQiLCJlbGVtZW50IiwiaXRlbXMiLCJnZXRMb2NhdGlvbiIsInN0YXJ0IiwiZ2V0U2xpY2UiLCJ2YWx1ZSIsInNjYW5UZW1wbGF0ZUVsZW1lbnQiLCJpbnRlcnAiLCJnZXQiLCJ0YWlsIiwiVEVNUExBVEUiLCJJREVOVElGSUVSIiwibG9va2FoZWFkIiwiRElWIiwic2NhblJlZ0V4cCIsImNoIiwib2N0YWwiLCJzY2FuU3RyaW5nRXNjYXBlIiwiY3JlYXRlSUxMRUdBTCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOztJQUFZQSxDOztBQUNaOztBQUNBOztBQUdBOzs7Ozs7OztBQUZBLE1BQU1DLE9BQU8sb0JBQU1BLElBQW5CO0FBQ0EsTUFBTUMsVUFBVSxvQkFBTUEsT0FBdEI7OztBQUdBLE1BQU1DLFVBQVUsRUFBRUMsTUFBTSxhQUFSLEVBQWhCO0FBQ0EsTUFBTUMsVUFBVSxFQUFFRCxNQUFNLGNBQVIsRUFBaEI7QUFDQSxNQUFNRSxLQUFLLEVBQUVDLE9BQU8sc0JBQVdDLFVBQXBCLEVBQWdDSixNQUFNLEdBQXRDLEVBQVg7O0FBR0E7QUFDQSxNQUFNSyxrQkFBa0IsQ0FBQyxNQUFELEVBQVMsTUFBVCxFQUFpQixNQUFqQixFQUF5QixPQUF6QixDQUF4Qjs7QUFFQTtBQUNBLE1BQU1DLGdCQUFpQlYsRUFBRVcsT0FBRixDQUFVLEVBQUVDLE1BQU0scUJBQVVDLE1BQWxCLEVBQVYsQ0FBdkI7QUFDQSxNQUFNQyxjQUFpQmQsRUFBRVcsT0FBRixDQUFVLEVBQUVDLE1BQU0scUJBQVVHLE1BQWxCLEVBQVYsQ0FBdkI7QUFDQSxNQUFNQyxjQUFpQmhCLEVBQUVXLE9BQUYsQ0FBVSxFQUFFQyxNQUFNLHFCQUFVSyxNQUFsQixFQUFWLENBQXZCO0FBQ0EsTUFBTUMsaUJBQWlCbEIsRUFBRVcsT0FBRixDQUFVLEVBQUVDLE1BQU0scUJBQVVPLE1BQWxCLEVBQVYsQ0FBdkI7QUFDQSxNQUFNQyxlQUFpQnBCLEVBQUVXLE9BQUYsQ0FBVSxFQUFFQyxNQUFNLHFCQUFVUyxNQUFsQixFQUFWLENBQXZCO0FBQ0EsTUFBTUMs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LGdCQUFJaUIsUUFBUSxLQUFLc0IsUUFBTCxDQUFjRCxLQUFkLEVBQXFCcEIsYUFBckIsQ0FBWjtBQUNBLGlCQUFLbEIsS0FBTCxJQUFjLENBQWQ7QUFDQSxtQkFBTztBQUNMakgsb0JBQU0scUJBQVU4SixRQURYO0FBRUxELG9CQUFNLEtBRkQ7QUFHTEYsc0JBQVEsSUFISDtBQUlMekIscUJBQU9BO0FBSkYsYUFBUDtBQU1EO0FBQ0QsZUFBS2pCLEtBQUw7QUFDQTtBQUNGLGFBQUssSUFBTDtBQUFZO0FBQ1o7QUFDRSxnQkFBSW1ELFFBQVEsS0FBS0MsZ0JBQUwsQ0FBc0IsRUFBdEIsRUFBMEIsSUFBMUIsRUFBZ0MsQ0FBaEMsQ0FBWjtBQUNBLGdCQUFJRCxTQUFTLElBQWIsRUFBbUI7QUFDakIsb0JBQU0sS0FBS0UsYUFBTCxFQUFOO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFDRSxlQUFLckQsS0FBTDtBQW5DSjtBQXFDRDs7QUFFRCxVQUFNLEtBQUtxRCxhQUFMLEVBQU47QUFDRDtBQXJOMkM7a0JBQXpCdEUsTSIsImZpbGUiOiJzaGlmdC1yZWFkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVG9rZW5pemVyIGZyb20gXCJzaGlmdC1wYXJzZXIvZGlzdC90b2tlbml6ZXJcIjtcbmltcG9ydCB7IFRva2VuQ2xhc3MsIFRva2VuVHlwZSB9IGZyb20gXCJzaGlmdC1wYXJzZXIvZGlzdC90b2tlbml6ZXJcIjtcbmltcG9ydCB7IExpc3QgfSBmcm9tIFwiaW1tdXRhYmxlXCI7XG5pbXBvcnQgU3ludGF4IGZyb20gXCIuL3N5bnRheFwiO1xuaW1wb3J0ICogYXMgUiBmcm9tICdyYW1kYSc7XG5pbXBvcnQgeyBNYXliZSB9IGZyb20gJ3JhbWRhLWZhbnRhc3knO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi9lcnJvcnMnO1xuY29uc3QgSnVzdCA9IE1heWJlLkp1c3Q7XG5jb25zdCBOb3RoaW5nID0gTWF5YmUuTm90aGluZztcbmltcG9ydCBUZXJtIGZyb20gJy4vdGVybXMnO1xuXG5jb25zdCBMU1lOVEFYID0geyBuYW1lOiAnbGVmdC1zeW50YXgnIH07XG5jb25zdCBSU1lOVEFYID0geyBuYW1lOiAncmlnaHQtc3ludGF4JyB9O1xuY29uc3QgQVQgPSB7IGtsYXNzOiBUb2tlbkNsYXNzLlB1bmN0dWF0b3IsIG5hbWU6IFwiQFwiIH07XG5cblxuLy8gVE9ETzogYWxzbywgbmVlZCB0byBoYW5kbGUgY29udGV4dHVhbCB5aWVsZFxuY29uc3QgbGl0ZXJhbEtleXdvcmRzID0gWyd0aGlzJywgJ251bGwnLCAndHJ1ZScsICdmYWxzZSddO1xuXG4vLyBUb2tlbiAtPiBCb29sZWFuXG5jb25zdCBpc0xlZnRCcmFja2V0ICA9IFIud2hlcmVFcSh7IHR5cGU6IFRva2VuVHlwZS5MQlJBQ0sgfSk7XG5jb25zdCBpc0xlZnRCcmFjZSAgICA9IFIud2hlcmVFcSh7IHR5cGU6IFRva2VuVHlwZS5MQlJBQ0UgfSk7XG5jb25zdCBpc0xlZnRQYXJlbiAgICA9IFIud2hlcmVFcSh7IHR5cGU6IFRva2VuVHlwZS5MUEFSRU4gfSk7XG5jb25zdCBpc1JpZ2h0QnJhY2tldCA9IFIud2hlcmVFcSh7IHR5cGU6IFRva2VuVHlwZS5SQlJBQ0sgfSk7XG5jb25zdCBpc1JpZ2h0QnJhY2UgICA9IFIud2hlcmVFcSh7IHR5cGU6IFRva2VuVHlwZS5SQlJBQ0UgfSk7XG5jb25zdCBpc1JpZ2h0UGFyZW4gICA9IFIud2hlcmVFcSh7IHR5cGU6IFRva2VuVHlwZS5SUEFSRU4gfSk7XG5cbmNvbnN0IGlzRU9TID0gUi53aGVyZUVxKHsgdHlwZTogVG9rZW5UeXBlLkVPUyB9KTtcblxuLy8gY29uc3QgaXNIYXNoID0gUi53aGVyZUVxKHsgdHlwZTogVG9rZW5UeXBlLklERU5USUZJRVIsIHZhbHVlOiAnIyd9KTtcbmNvbnN0IGlzTGVmdFN5bnRheCA9IFIud2hlcmVFcSh7IHR5cGU6IExTWU5UQVggfSk7XG5jb25zdCBpc1JpZ2h0U3ludGF4ID0gUi53aGVyZUVxKHsgdHlwZTogUlNZTlRBWCB9KTtcblxuY29uc3QgaXNMZWZ0RGVsaW1pdGVyID0gUi5hbnlQYXNzKFtpc0xlZnRCcmFja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlZnRCcmFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWZ0UGFyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVmdFN5bnRheF0pO1xuXG5jb25zdCBpc1JpZ2h0RGVsaW1pdGVyID0gUi5hbnlQYXNzKFtpc1JpZ2h0QnJhY2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmlnaHRCcmFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmlnaHRQYXJlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmlnaHRTeW50YXhdKTtcblxuY29uc3QgaXNNYXRjaGluZ0RlbGltaXRlcnMgPSBSLmNvbmQoW1xuICBbaXNMZWZ0QnJhY2tldCwgKF8sIGIpID0+IGlzUmlnaHRCcmFja2V0KGIpXSxcbiAgW2lzTGVmdEJyYWNlLCAoXywgYikgPT4gaXNSaWdodEJyYWNlKGIpXSxcbiAgW2lzTGVmdFBhcmVuLCAoXywgYikgPT4gaXNSaWdodFBhcmVuKGIpXSxcbiAgW2lzTGVmdFN5bnRheCwgKF8sIGIpID0+IGlzUmlnaHRTeW50YXgoYildLFxuICBbUi5ULCBSLkZdXG5dKTtcblxuY29uc3QgYXNzaWduT3BzID0gIFtcIj1cIiwgXCIrPVwiLCBcIi09XCIsIFwiKj1cIiwgXCIvPVwiLCBcIiU9XCIsIFwiPDw9XCIsIFwiPj49XCIsIFwiPj4+PVwiLFxuICAgICAgICAgICAgICAgICAgXCImPVwiLCBcInw9XCIsIFwiXj1cIiwgXCIsXCJdO1xuXG5jb25zdCBiaW5hcnlPcHMgPSBbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvXCIsIFwiJVwiLFwiPDxcIiwgXCI+PlwiLCBcIj4+PlwiLCBcIiZcIiwgXCJ8XCIsIFwiXlwiLFxuICAgICAgICAgICAgICAgICBcIiYmXCIsIFwifHxcIiwgXCI/XCIsIFwiOlwiLFxuICAgICAgICAgICAgICAgICBcIj09PVwiLCBcIj09XCIsIFwiPj1cIiwgXCI8PVwiLCBcIjxcIiwgXCI+XCIsIFwiIT1cIiwgXCIhPT1cIiwgXCJpbnN0YW5jZW9mXCJdO1xuXG5jb25zdCB1bmFyeU9wcyA9IFtcIisrXCIsIFwiLS1cIiwgXCJ+XCIsIFwiIVwiLCBcImRlbGV0ZVwiLCBcInZvaWRcIiwgXCJ0eXBlb2ZcIiwgXCJ5aWVsZFwiLCBcInRocm93XCIsIFwibmV3XCJdO1xuXG4vLyBMaXN0IC0+IEJvb2xlYW5cbmNvbnN0IGlzRW1wdHkgPSBSLndoZXJlRXEoe3NpemU6IDB9KTtcblxuLy8gU3ludGF4IC0+IEJvb2xlYW5cbmNvbnN0IGlzUHVuY3R1YXRvciA9IHMgPT4gcy5tYXRjaChcInB1bmN0dWF0b3JcIik7XG5jb25zdCBpc0tleXdvcmQgPSBzID0+IHMubWF0Y2goXCJrZXl3b3JkXCIpO1xuY29uc3QgaXNQYXJlbnMgPSBzID0+IHMubWF0Y2goXCJwYXJlbnNcIik7XG5jb25zdCBpc0JyYWNlcyA9IHMgPT4gcy5tYXRjaChcImJyYWNlc1wiKTtcbmNvbnN0IGlzSWRlbnRpZmllciA9IHMgPT4gcy5tYXRjaChcImlkZW50aWZpZXJcIik7XG5cbi8vIEFueSAtPiBTeW50YXggLT4gQm9vbGVhblxuY29uc3QgaXNWYWwgPSBSLmN1cnJ5KCh2LCBzKSA9PiBzLnZhbCgpID09PSB2KTtcblxuLy8gU3ludGF4IC0+IEJvb2xlYW5cbmNvbnN0IGlzRG90ID0gUi5hbGxQYXNzKFtpc1B1bmN0dWF0b3IsIGlzVmFsKCcuJyldKTtcbmNvbnN0IGlzQ29sb24gPSBSLmFsbFBhc3MoW2lzUHVuY3R1YXRvciwgaXNWYWwoJzonKV0pO1xuY29uc3QgaXNGdW5jdGlvbktleXdvcmQgPSBSLmFsbFBhc3MoW2lzS2V5d29yZCwgaXNWYWwoJ2Z1bmN0aW9uJyldKTtcbmNvbnN0IGlzT3BlcmF0b3IgPSBzID0+IChzLm1hdGNoKFwicHVuY3R1YXRvclwiKSB8fCBzLm1hdGNoKFwia2V5d29yZFwiKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUi5hbnkoUi5lcXVhbHMocy52YWwoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbk9wcy5jb25jYXQoYmluYXJ5T3BzKS5jb25jYXQodW5hcnlPcHMpKTtcbmNvbnN0IGlzTm9uTGl0ZXJhbEtleXdvcmQgPSBSLmFsbFBhc3MoW2lzS2V5d29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPT4gUi5ub25lKFIuZXF1YWxzKHMudmFsKCkpLCBsaXRlcmFsS2V5d29yZHMpXSk7XG5jb25zdCBpc0tleXdvcmRFeHByUHJlZml4ID0gUi5hbGxQYXNzKFtpc0tleXdvcmQsXG4gIHMgPT4gUi5hbnkoUi5lcXVhbHMocy52YWwoKSksIFsnaW5zdGFuY2VvZicsICd0eXBlb2YnLCAnZGVsZXRlJywgJ3ZvaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd5aWVsZCcsICd0aHJvdycsICduZXcnLCAnY2FzZSddKV0pO1xuLy8gTGlzdCBhIC0+IGE/XG5sZXQgbGFzdCA9IHAgPT4gcC5sYXN0KCk7XG4vLyBMaXN0IGEgLT4gTWF5YmUgYVxubGV0IHNhZmVMYXN0ID0gUi5waXBlKFIuY29uZChbXG4gIFtpc0VtcHR5LCBSLmFsd2F5cyhOb3RoaW5nKCkpXSxcbiAgW1IuVCwgUi5jb21wb3NlKE1heWJlLm9mLCBsYXN0KV1cbl0pKTtcblxuLy8gVE9ETzogYmV0dGVyIG5hbWVcbi8vIExpc3QgLT4gQm9vbGVhbiAtPiBNYXliZSBMaXN0XG5sZXQgc3R1ZmZUcnVlID0gUi5jdXJyeSgocCwgYikgPT4gYiA/IEp1c3QocCkgOiBOb3RoaW5nKCkpO1xubGV0IHN0dWZmRmFsc2UgPSBSLmN1cnJ5KChwLCBiKSA9PiAhYiA/IEp1c3QocCkgOiBOb3RoaW5nKCkpO1xuXG4vLyBMaXN0IGEgLT4gQm9vbGVhblxubGV0IGlzVG9wQ29sb24gPSBSLnBpcGUoXG4gIHNhZmVMYXN0LFxuICBSLm1hcChpc0NvbG9uKSxcbiAgTWF5YmUubWF5YmUoZmFsc2UsIFIuaWRlbnRpdHkpXG4pO1xuLy8gTGlzdCBhIC0+IEJvb2xlYW5cbmxldCBpc1RvcFB1bmN0dWF0b3IgPSBSLnBpcGUoXG4gIHNhZmVMYXN0LFxuICBSLm1hcChpc1B1bmN0dWF0b3IpLFxuICBNYXliZS5tYXliZShmYWxzZSwgUi5pZGVudGl0eSlcbik7XG5cbi8vIE51bWJlciAtPiBMaXN0IC0+IEJvb2xlYW5cbmxldCBpc0V4cHJSZXR1cm4gPSBSLmN1cnJ5KChsLCBwKSA9PiB7XG4gIGxldCByZXRLd2QgPSBzYWZlTGFzdChwKTtcbiAgbGV0IG1heWJlRG90ID0gcG9wKHApLmNoYWluKHNhZmVMYXN0KTtcblxuICBpZiAobWF5YmVEb3QubWFwKGlzRG90KS5nZXRPckVsc2UoZmFsc2UpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldEt3ZC5tYXAocyA9PiB7XG4gICAgcmV0dXJuIHMubWF0Y2goXCJrZXl3b3JkXCIpICYmIHMudmFsKCkgPT09ICdyZXR1cm4nICYmIHMubGluZU51bWJlcigpID09PSBsO1xuICB9KS5nZXRPckVsc2UoZmFsc2UpO1xufSk7XG5cbmNvbnN0IGlzVG9wT3BlcmF0b3IgPSBSLnBpcGUoXG4gIHNhZmVMYXN0LFxuICBSLm1hcChpc09wZXJhdG9yKSxcbiAgTWF5YmUubWF5YmUoZmFsc2UsIFIuaWRlbnRpdHkpXG4pO1xuXG5jb25zdCBpc1RvcEtleXdvcmRFeHByUHJlZml4ID0gUi5waXBlKFxuICBzYWZlTGFzdCxcbiAgUi5tYXAoaXNLZXl3b3JkRXhwclByZWZpeCksXG4gIE1heWJlLm1heWJlKGZhbHNlLCBSLmlkZW50aXR5KVxuKTtcblxuLy8gTnVtYmVyIC0+IEJvb2xlYW4gLT4gTGlzdCAtPiBCb29sZWFuXG5sZXQgaXNFeHByUHJlZml4ID0gUi5jdXJyeSgobCwgYikgPT4gUi5jb25kKFtcbiAgLy8gLi4uICh7eDogNDJ9IC9yL2kpXG4gIFtpc0VtcHR5LCBSLmFsd2F5cyhiKV0sXG4gIC8vIC4uLiAoe3g6IHt4OiA0Mn0gL3IvaSB9KVxuICBbaXNUb3BDb2xvbiwgUi5hbHdheXMoYildLFxuICAvLyAuLi4gdGhyb3cge3g6IDQyfSAvci9pXG4gIFtpc1RvcEtleXdvcmRFeHByUHJlZml4LCBSLlRdLFxuICAvLyAuLi4gNDIgKyB7eDogNDJ9IC9yL2lcbiAgW2lzVG9wT3BlcmF0b3IsIFIuVF0sXG4gIC8vIC4uLiBmb3IgKCA7IHt4OiA0Mn0vci9pKVxuICBbaXNUb3BQdW5jdHVhdG9yLCBSLmFsd2F5cyhiKV0sXG4gIC8vIC4uLiByZXR1cm4ge3g6IDQyfSAvciAvaVxuICAvLyAuLi4gcmV0dXJuXFxue3g6IDQyfSAvciAvaVxuICBbaXNFeHByUmV0dXJuKGwpLCBSLlRdLFxuICBbUi5ULCBSLkZdLFxuXSkpO1xuXG4vLyBMaXN0IGEgLT4gTWF5YmUgTGlzdCBhXG5sZXQgY3VybHkgPSBwID0+IHNhZmVMYXN0KHApLm1hcChpc0JyYWNlcykuY2hhaW4oc3R1ZmZUcnVlKHApKTtcbmxldCBwYXJlbiA9IHAgPT4gc2FmZUxhc3QocCkubWFwKGlzUGFyZW5zKS5jaGFpbihzdHVmZlRydWUocCkpO1xubGV0IGZ1bmMgPSBwID0+IHNhZmVMYXN0KHApLm1hcChpc0Z1bmN0aW9uS2V5d29yZCkuY2hhaW4oc3R1ZmZUcnVlKHApKTtcbmxldCBpZGVudCA9IHAgPT4gc2FmZUxhc3QocCkubWFwKGlzSWRlbnRpZmllcikuY2hhaW4oc3R1ZmZUcnVlKHApKTtcbmxldCBub25MaXRlcmFsS2V5d29yZCA9IHAgPT4gc2FmZUxhc3QocCkubWFwKGlzTm9uTGl0ZXJhbEtleXdvcmQpLmNoYWluKHN0dWZmVHJ1ZShwKSk7XG5cbmxldCBvcHQgPSBSLmN1cnJ5KChhLCBiLCBwKSA9PiB7XG4gIGxldCByZXN1bHQgPSBSLnBpcGVLKGEsIGIpKE1heWJlLm9mKHApKTtcbiAgcmV0dXJuIE1heWJlLmlzSnVzdChyZXN1bHQpID8gcmVzdWx0IDogTWF5YmUub2YocCk7XG59KTtcblxubGV0IG5vdERvdCA9IFIuaWZFbHNlKFxuICBSLndoZXJlRXEoe3NpemU6IDB9KSxcbiAgSnVzdCxcbiAgcCA9PiBzYWZlTGFzdChwKS5tYXAocyA9PiAhKHMubWF0Y2goXCJwdW5jdHVhdG9yXCIpICYmIHMudmFsKCkgPT09ICcuJykpLmNoYWluKHN0dWZmVHJ1ZShwKSlcbik7XG5cbi8vIExpc3QgYSAtPiBNYXliZSBMaXN0IGFcbmxldCBwb3AgPSBSLmNvbXBvc2UoSnVzdCwgcCA9PiBwLnBvcCgpKTtcblxuLy8gTWF5YmUgTGlzdCBhIC0+IE1heWJlIExpc3QgYVxuY29uc3QgZnVuY3Rpb25QcmVmaXggPSBSLnBpcGVLKFxuICAgIGN1cmx5LFxuICAgIHBvcCxcbiAgICBwYXJlbixcbiAgICBwb3AsXG4gICAgb3B0KGlkZW50LCBwb3ApLFxuICAgIGZ1bmMpO1xuXG4vLyBCb29sZWFuIC0+IExpc3QgYSAtPiBCb29sZWFuXG5jb25zdCBpc1JlZ2V4UHJlZml4ID0gYiA9PiBSLmFueVBhc3MoW1xuICAvLyDOtVxuICBpc0VtcHR5LFxuICAvLyBQIC4gdCAgIHdoZXJlIHQg4oiIIFB1bmN0dWF0b3JcbiAgaXNUb3BQdW5jdHVhdG9yLFxuICAvLyBQIC4gdCAuIHQnICB3aGVyZSB0IFxcbm90ID0gXCIuXCIgYW5kIHQnIOKIiCAoS2V5d29yZCBcXHNldG1pbnVzICBMaXRlcmFsS2V5d29yZClcbiAgUi5waXBlKFxuICAgIE1heWJlLm9mLFxuICAgIFIucGlwZUsoXG4gICAgICBub25MaXRlcmFsS2V5d29yZCxcbiAgICAgIHBvcCxcbiAgICAgIG5vdERvdFxuICAgICksXG4gICAgTWF5YmUuaXNKdXN0XG4gICksXG4gIC8vIFAgLiB0IC4gdCcgLiAoVCkgIHdoZXJlIHQgXFxub3QgPSBcIi5cIiBhbmQgdCcg4oiIIChLZXl3b3JkIFxcc2V0bWludXMgTGl0ZXJhbEtleXdvcmQpXG4gIFIucGlwZShcbiAgICBNYXliZS5vZixcbiAgICBSLnBpcGVLKFxuICAgICAgcGFyZW4sXG4gICAgICBwb3AsXG4gICAgICBub25MaXRlcmFsS2V5d29yZCxcbiAgICAgIHBvcCxcbiAgICAgIG5vdERvdFxuICAgICksXG4gICAgTWF5YmUuaXNKdXN0XG4gICksXG4gIC8vIFAgLiBmdW5jdGlvbl5sIC4geD8gLiAoKSAuIHt9ICAgICB3aGVyZSBpc0V4cHJQcmVmaXgoUCwgYiwgbCkgPSBmYWxzZVxuICBSLnBpcGUoXG4gICAgTWF5YmUub2YsXG4gICAgZnVuY3Rpb25QcmVmaXgsXG4gICAgUi5jaGFpbihwID0+IHtcbiAgICAgICAgcmV0dXJuIHNhZmVMYXN0KHApXG4gICAgICAgICAgLm1hcChzID0+IHMubGluZU51bWJlcigpKVxuICAgICAgICAgIC5jaGFpbihmbkxpbmUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBvcChwKS5tYXAoaXNFeHByUHJlZml4KGZuTGluZSwgYikpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNoYWluKHN0dWZmRmFsc2UocCkpO1xuICAgICAgfVxuICAgICksXG4gICAgTWF5YmUuaXNKdXN0XG4gICksXG4gIC8vIFAgLiB7VH1ebCAgd2hlcmUgaXNFeHByUHJlZml4KFAsIGIsIGwpID0gZmFsc2VcbiAgcCA9PiB7XG4gICAgbGV0IGFscmVhZHlDaGVja2VkRnVuY3Rpb24gPSBSLnBpcGUoXG4gICAgICBNYXliZS5vZixcbiAgICAgIGZ1bmN0aW9uUHJlZml4LFxuICAgICAgTWF5YmUuaXNKdXN0XG4gICAgKShwKTtcbiAgICBpZiAoYWxyZWFkeUNoZWNrZWRGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gUi5waXBlKFxuICAgICAgTWF5YmUub2YsXG4gICAgICBSLmNoYWluKGN1cmx5KSxcbiAgICAgIFIuY2hhaW4ocCA9PiB7XG4gICAgICAgIHJldHVybiBzYWZlTGFzdChwKVxuICAgICAgICAubWFwKHMgPT4gcy5saW5lTnVtYmVyKCkpXG4gICAgICAgIC5jaGFpbihjdXJseUxpbmUgPT4ge1xuICAgICAgICAgIHJldHVybiBwb3AocCkubWFwKGlzRXhwclByZWZpeChjdXJseUxpbmUsIGIpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNoYWluKHN0dWZmRmFsc2UocCkpO1xuICAgICAgfSksXG4gICAgICBNYXliZS5pc0p1c3RcbiAgICApKHApO1xuICB9XG5cblxuXSk7XG5cbmZ1bmN0aW9uIGxhc3RFbChsKSB7XG4gIHJldHVybiBsW2wubGVuZ3RoIC0gMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWRlciBleHRlbmRzIFRva2VuaXplciB7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ3MsIGNvbnRleHQsIHJlcGxhY2VtZW50cykge1xuICAgIHN1cGVyKEFycmF5LmlzQXJyYXkoc3RyaW5ncykgPyBzdHJpbmdzLmpvaW4oJycpIDogc3RyaW5ncyk7XG4gICAgdGhpcy5kZWxpbVN0YWNrID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaW5zaWRlU3ludGF4VGVtcGxhdGUgPSBbZmFsc2VdO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAvLyBzZXR1cCBzcGxpY2luZyByZXBsYWNlbWVudCBhcnJheVxuICAgIGlmIChBcnJheS5pc0FycmF5KHN0cmluZ3MpKSB7XG4gICAgICBsZXQgdG90YWxJbmRleCA9IDA7XG4gICAgICB0aGlzLnJlcGxhY2VtZW50SW5kZXggPSBSLnJlZHVjZSgoYWNjLCBzdHJSZXApID0+IHtcbiAgICAgICAgYWNjLnB1c2goe1xuICAgICAgICAgIGluZGV4OiB0b3RhbEluZGV4ICsgc3RyUmVwWzBdLmxlbmd0aCxcbiAgICAgICAgICByZXBsYWNlbWVudDogc3RyUmVwWzFdXG4gICAgICAgIH0pO1xuICAgICAgICB0b3RhbEluZGV4ICs9IHN0clJlcFswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBbXSwgUi56aXAoc3RyaW5ncywgcmVwbGFjZW1lbnRzKSk7XG4gICAgfVxuICB9XG5cbiAgcmVhZChzdGFjayA9IFtdLCBiID0gZmFsc2UsIHNpbmdsZURlbGltaXRlciA9IGZhbHNlKSB7XG4gICAgbGV0IHByZWZpeCA9IExpc3QoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IHRvayA9IHRoaXMuYWR2YW5jZShwcmVmaXgsIGIpO1xuXG4gICAgICAvLyBzcGxpY2luZyBhbGxvd3Mgc3ludGF4IGFuZCB0ZXJtc1xuICAgICAgaWYgKHRvay5zY29wZXNldHMgfHwgdG9rIGluc3RhbmNlb2YgVGVybSkge1xuICAgICAgICBzdGFjay5wdXNoKHRvayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rKSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzdGFjaywgdG9rKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoTGlzdC5pc0xpc3QodG9rKSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzdGFjaywgdG9rLnRvQXJyYXkoKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFT1ModG9rKSkge1xuICAgICAgICBpZiAoc3RhY2tbMF0gJiYgaXNMZWZ0RGVsaW1pdGVyKHN0YWNrWzBdLnRva2VuKSkge1xuICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlVW5leHBlY3RlZCh0b2spO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMZWZ0RGVsaW1pdGVyKHRvaykpIHtcbiAgICAgICAgaWYgKGlzTGVmdFN5bnRheCh0b2spKSB7XG4gICAgICAgICAgdGhpcy5pbnNpZGVTeW50YXhUZW1wbGF0ZS5wdXNoKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lID0gdG9rLnNsaWNlLnN0YXJ0TG9jYXRpb24ubGluZTtcbiAgICAgICAgbGV0IGlubmVyQiA9IGlzTGVmdEJyYWNlKHRvaykgPyBpc0V4cHJQcmVmaXgobGluZSwgYikocHJlZml4KSA6IHRydWU7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMucmVhZChbbmV3IFN5bnRheCh0b2ssIHRoaXMuY29udGV4dCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJCLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICBsZXQgc3R4ID0gbmV3IFN5bnRheChpbm5lciwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LmNvbmNhdChzdHgpO1xuICAgICAgICBzdGFjay5wdXNoKHN0eCk7XG4gICAgICAgIGlmIChzaW5nbGVEZWxpbWl0ZXIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1JpZ2h0RGVsaW1pdGVyKHRvaykpIHtcbiAgICAgICAgaWYgKHN0YWNrWzBdICYmICFpc01hdGNoaW5nRGVsaW1pdGVycyhzdGFja1swXS50b2tlbiwgdG9rKSkge1xuICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlVW5leHBlY3RlZCh0b2spO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHggPSBuZXcgU3ludGF4KHRvaywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgc3RhY2sucHVzaChzdHgpO1xuICAgICAgICBpZiAobGFzdEVsKHRoaXMuaW5zaWRlU3ludGF4VGVtcGxhdGUpICYmIGlzUmlnaHRTeW50YXgodG9rKSkge1xuICAgICAgICAgIHRoaXMuaW5zaWRlU3ludGF4VGVtcGxhdGUucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc3R4ID0gbmV3IFN5bnRheCh0b2ssIHRoaXMuY29udGV4dCk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC5jb25jYXQoc3R4KTtcbiAgICAgICAgc3RhY2sucHVzaChzdHgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTGlzdChzdGFjayk7XG4gIH1cblxuICBhZHZhbmNlKHByZWZpeCwgYikge1xuICAgIHRoaXMubGFzdEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB0aGlzLmxhc3RMaW5lID0gdGhpcy5saW5lO1xuICAgIHRoaXMubGFzdExpbmVTdGFydCA9IHRoaXMubGluZVN0YXJ0O1xuXG4gICAgdGhpcy5za2lwQ29tbWVudCgpO1xuXG4gICAgdGhpcy5zdGFydEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB0aGlzLnN0YXJ0TGluZSA9IHRoaXMubGluZTtcbiAgICB0aGlzLnN0YXJ0TGluZVN0YXJ0ID0gdGhpcy5saW5lU3RhcnQ7XG5cbiAgICBpZiAodGhpcy5yZXBsYWNlbWVudEluZGV4ICYmIHRoaXMucmVwbGFjZW1lbnRJbmRleFswXSAmJiB0aGlzLmluZGV4ID49IHRoaXMucmVwbGFjZW1lbnRJbmRleFswXS5pbmRleCkge1xuICAgICAgbGV0IHJlcCA9IHRoaXMucmVwbGFjZW1lbnRJbmRleFswXS5yZXBsYWNlbWVudDtcbiAgICAgIHRoaXMucmVwbGFjZW1lbnRJbmRleC5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHJlcDtcbiAgICB9XG5cbiAgICBsZXQgY2hhckNvZGUgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuXG4gICAgaWYgKGNoYXJDb2RlID09PSAweDYwKSB7IC8vIGBcbiAgICAgIGxldCBlbGVtZW50LCBpdGVtcyA9IFtdO1xuICAgICAgbGV0IHN0YXJ0TG9jYXRpb24gPSB0aGlzLmdldExvY2F0aW9uKCk7XG4gICAgICBsZXQgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgaWYgKGxhc3RFbCh0aGlzLmluc2lkZVN5bnRheFRlbXBsYXRlKSkge1xuXG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIHN0YXJ0TG9jYXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFJTWU5UQVgsXG4gICAgICAgICAgdmFsdWU6ICdgJyxcbiAgICAgICAgICBzbGljZTogc2xpY2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRvIHtcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuc2NhblRlbXBsYXRlRWxlbWVudCgpO1xuICAgICAgICBpdGVtcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5pbnRlcnApIHtcbiAgICAgICAgICAvLyBvbmx5IHJlYWQgdGhlIHNpbmdsZSBkZWxpbWl0ZXJcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5yZWFkKFtdLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgYXNzZXJ0KGVsZW1lbnQuc2l6ZSA9PT0gMSwgXCJzaG91bGQgb25seSBoYXZlIHJlYWQgYSBzaW5nbGUgZGVsaW1pdGVyIGluc2lkZSBhIHRlbXBsYXRlXCIpO1xuICAgICAgICAgIGl0ZW1zLnB1c2goZWxlbWVudC5nZXQoMCkpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghZWxlbWVudC50YWlsKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFRva2VuVHlwZS5URU1QTEFURSxcbiAgICAgICAgaXRlbXM6IExpc3QoaXRlbXMpLFxuICAgICAgICBzbGljZTogdGhpcy5nZXRTbGljZShzdGFydCwgc3RhcnRMb2NhdGlvbilcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMzUpIHsgLy8gI1xuICAgICAgbGV0IHN0YXJ0TG9jYXRpb24gPSB0aGlzLmdldExvY2F0aW9uKCk7XG4gICAgICBsZXQgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgbGV0IHNsaWNlID0gdGhpcy5nZXRTbGljZShzdGFydCwgc3RhcnRMb2NhdGlvbik7XG4gICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAvLyBUT0RPOiBoYW5kbGUgYCBpbnNpZGUgb2Ygc3ludGF4IHRlbXBsYXRlIGludGVycG9sYXRpb25zXG4gICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSA9PT0gMHg2MCkgeyAvLyBgXG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBMU1lOVEFYLFxuICAgICAgICAgIHZhbHVlOiAnI2AnLFxuICAgICAgICAgIHNsaWNlOiBzbGljZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogVG9rZW5UeXBlLklERU5USUZJRVIsXG4gICAgICAgIHZhbHVlOiAnIycsXG4gICAgICAgIHNsaWNlOiBzbGljZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09PSA2NCkgeyAvLyBAXG4gICAgICBsZXQgc3RhcnRMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYXRpb24oKTtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICBsZXQgc2xpY2UgPSB0aGlzLmdldFNsaWNlKHN0YXJ0LCBzdGFydExvY2F0aW9uKTtcbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IEFULFxuICAgICAgICB2YWx1ZTogJ0AnLFxuICAgICAgICBzbGljZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgbG9va2FoZWFkID0gc3VwZXIuYWR2YW5jZSgpO1xuICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW5UeXBlLkRJViAmJiBpc1JlZ2V4UHJlZml4KGIpKHByZWZpeCkpIHtcbiAgICAgIHJldHVybiBzdXBlci5zY2FuUmVnRXhwKFwiL1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvb2thaGVhZDtcbiAgfVxuXG4gIC8vIG5lZWQgdG8gb3ZlcnJpZGUgaG93IHRlbXBsYXRlcyBhcmUgbGV4ZWQgYmVjYXVzZSBvZiBkZWxpbWl0ZXJzXG4gIHNjYW5UZW1wbGF0ZUVsZW1lbnQoKSB7XG4gICAgbGV0IHN0YXJ0TG9jYXRpb24gPSB0aGlzLmdldExvY2F0aW9uKCk7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMuc291cmNlLmxlbmd0aCkge1xuICAgICAgbGV0IGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAweDYwOiB7IC8vIGBcbiAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSB0cmFsaW5nIFwiYFwiXG4gICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5nZXRTbGljZShzdGFydCwgc3RhcnRMb2NhdGlvbik7XG4gICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlblR5cGUuVEVNUExBVEUsXG4gICAgICAgICAgICB0YWlsOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJwOiBmYWxzZSxcbiAgICAgICAgICAgIHNsaWNlOiBzbGljZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAweDI0OiAgLy8gJFxuICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHg3QikgeyAgLy8ge1xuICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSB0aGUgdHJhaWxpbmcgXCIkXCJcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuZ2V0U2xpY2Uoc3RhcnQsIHN0YXJ0TG9jYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5UeXBlLlRFTVBMQVRFLFxuICAgICAgICAgICAgICB0YWlsOiBmYWxzZSxcbiAgICAgICAgICAgICAgaW50ZXJwOiB0cnVlLFxuICAgICAgICAgICAgICBzbGljZTogc2xpY2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDVDOiAgLy8gXFxcXFxuICAgICAgICB7XG4gICAgICAgICAgbGV0IG9jdGFsID0gdGhpcy5zY2FuU3RyaW5nRXNjYXBlKFwiXCIsIG51bGwpWzFdO1xuICAgICAgICAgIGlmIChvY3RhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUlMTEVHQUwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgdGhpcy5jcmVhdGVJTExFR0FMKCk7XG4gIH1cbn1cbiJdfQ==